package moduledata

// this code is straight from https://github.com/martende/restartable

import (
	"debug/elf"
	"errors"
	"os"
	"unsafe"
)

import "C"

type method struct {
	name    *string
	pkgpath *string
	mtyp    *_type
	typ     *_type
	ifn     unsafe.Pointer
	tfn     unsafe.Pointer
}

type uncommontype struct {
	name    *string
	pkgpath *string
	mhdr    []method
}

type _type struct {
	size       uintptr
	ptrdata    uintptr // size of memory prefix holding all pointers
	hash       uint32
	_unused    uint8
	align      uint8
	fieldalign uint8
	kind       uint8
	alg        *typeAlg
	// gcdata stores the GC type data for the garbage collector.
	// If the KindGCProg bit is set in kind, gcdata is a GC program.
	// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.
	gcdata  *byte
	_string *string
	x       *uncommontype
	ptrto   *_type
}

type functab struct {
	entry   uintptr
	funcoff uintptr
}

type modulehash struct {
	modulename   string
	linktimehash string
	runtimehash  *string
}
type bitvector struct {
	n        int32 // # of bits
	bytedata *uint8
}

// typeAlg is also copied/used in reflect/type.go.
// keep them in sync.
type typeAlg struct {
	// function for hashing objects of this type
	// (ptr to object, seed) -> hash
	hash func(unsafe.Pointer, uintptr) uintptr
	// function for comparing objects of this type
	// (ptr to object A, ptr to object B) -> ==?
	equal func(unsafe.Pointer, unsafe.Pointer) bool
}

type moduledata struct {
	pclntable    []byte
	ftab         []functab
	filetab      []uint32
	findfunctab  uintptr
	minpc, maxpc uintptr

	text, etext           uintptr
	noptrdata, enoptrdata uintptr
	data, edata           uintptr
	bss, ebss             uintptr
	noptrbss, enoptrbss   uintptr
	end, gcdata, gcbss    uintptr

	typelinks []*_type

	modulename   string
	modulehashes []modulehash

	gcdatamask, gcbssmask bitvector

	next *moduledata
}

// return list of modules from the specified executable
func GetModules(filename string) ([]string, error) {
	f, err := elf.Open(filename)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	syms, err := f.Symbols()
	if err != nil {
		return nil, err
	}
	var modSym elf.Symbol
	var modSymFound = false
	for _, v := range syms {
		if v.Name == "runtime.firstmoduledata" {
			modSym = v
			modSymFound = true
			break
		}
	}
	if !modSymFound {
		return nil, errors.New("elfparse:nosym")
	}

	var datap = (*moduledata)(unsafe.Pointer(uintptr(modSym.Value)))

	files := make([]string, 0)
	for i := range datap.filetab {
		bp := &datap.pclntable[datap.filetab[i]]
		file := C.GoString((*C.char)(unsafe.Pointer(bp)))
		if file != "<autogenerated>" && file != "@" {
			if _, err := os.Stat(file); err == nil {
				files = append(files, file)
			}
		}
	}

	return files, nil
}
